// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: playlist_query.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addSongToPlaylist = `-- name: AddSongToPlaylist :exec
INSERT INTO playlist_song (song_id, playlist_id)
VALUES ($1::int, $2::int)
`

type AddSongToPlaylistParams struct {
	SongID     int32 `json:"song_id"`
	PlaylistID int32 `json:"playlist_id"`
}

func (q *Queries) AddSongToPlaylist(ctx context.Context, arg AddSongToPlaylistParams) error {
	_, err := q.db.Exec(ctx, addSongToPlaylist, arg.SongID, arg.PlaylistID)
	return err
}

const adminDeletePlaylist = `-- name: AdminDeletePlaylist :exec
DELETE FROM playlist where id = $1::int
`

func (q *Queries) AdminDeletePlaylist(ctx context.Context, playlistID int32) error {
	_, err := q.db.Exec(ctx, adminDeletePlaylist, playlistID)
	return err
}

const checkOwnerPlaylist = `-- name: CheckOwnerPlaylist :one
SELECT account_id, id FROM playlist WHERE account_id = $1 and id = $2
`

type CheckOwnerPlaylistParams struct {
	AccountID pgtype.Int4 `json:"account_id"`
	ID        int32       `json:"id"`
}

type CheckOwnerPlaylistRow struct {
	AccountID pgtype.Int4 `json:"account_id"`
	ID        int32       `json:"id"`
}

func (q *Queries) CheckOwnerPlaylist(ctx context.Context, arg CheckOwnerPlaylistParams) (CheckOwnerPlaylistRow, error) {
	row := q.db.QueryRow(ctx, checkOwnerPlaylist, arg.AccountID, arg.ID)
	var i CheckOwnerPlaylistRow
	err := row.Scan(&i.AccountID, &i.ID)
	return i, err
}

const checkSongInPlaylist = `-- name: CheckSongInPlaylist :one
SELECT count(*) 
FROM playlist_song
where song_id = $1::int and playlist_id = $2::int
`

type CheckSongInPlaylistParams struct {
	SongID     int32 `json:"song_id"`
	PlaylistID int32 `json:"playlist_id"`
}

func (q *Queries) CheckSongInPlaylist(ctx context.Context, arg CheckSongInPlaylistParams) (int64, error) {
	row := q.db.QueryRow(ctx, checkSongInPlaylist, arg.SongID, arg.PlaylistID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPlaylist = `-- name: CreatePlaylist :one
INSERT INTO playlist (name, thumbnail, artist_id, description,category_id)
VALUES(
    $1, 
    $2,
    $3,
    $4,
    $5
) RETURNING id, name, thumbnail, account_id, artist_id, category_id, description, created_at, updated_at
`

type CreatePlaylistParams struct {
	Name        string      `json:"name"`
	Thumbnail   pgtype.Text `json:"thumbnail"`
	ArtistID    pgtype.Int4 `json:"artist_id"`
	Description pgtype.Text `json:"description"`
	CategoryID  pgtype.Int4 `json:"category_id"`
}

func (q *Queries) CreatePlaylist(ctx context.Context, arg CreatePlaylistParams) (Playlist, error) {
	row := q.db.QueryRow(ctx, createPlaylist,
		arg.Name,
		arg.Thumbnail,
		arg.ArtistID,
		arg.Description,
		arg.CategoryID,
	)
	var i Playlist
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Thumbnail,
		&i.AccountID,
		&i.ArtistID,
		&i.CategoryID,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserPlaylist = `-- name: CreateUserPlaylist :one
INSERT INTO playlist (account_id, name)
VALUES($1::int, $2) RETURNING id, name, thumbnail, account_id, artist_id, category_id, description, created_at, updated_at
`

type CreateUserPlaylistParams struct {
	UserID int32  `json:"user_id"`
	Name   string `json:"name"`
}

func (q *Queries) CreateUserPlaylist(ctx context.Context, arg CreateUserPlaylistParams) (Playlist, error) {
	row := q.db.QueryRow(ctx, createUserPlaylist, arg.UserID, arg.Name)
	var i Playlist
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Thumbnail,
		&i.AccountID,
		&i.ArtistID,
		&i.CategoryID,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePlaylist = `-- name: DeletePlaylist :exec
DELETE FROM playlist where account_id = $1::int and id = $2::int
`

type DeletePlaylistParams struct {
	UserID     int32 `json:"user_id"`
	PlaylistID int32 `json:"playlist_id"`
}

func (q *Queries) DeletePlaylist(ctx context.Context, arg DeletePlaylistParams) error {
	_, err := q.db.Exec(ctx, deletePlaylist, arg.UserID, arg.PlaylistID)
	return err
}

const getAllPlaylist = `-- name: GetAllPlaylist :many
SELECT p.id, p.name, p.thumbnail, p.account_id, p.artist_id, p.category_id, p.description, p.created_at, p.updated_at 
FROM playlist p 
WHERE p.account_id is null
ORDER BY p.updated_at DESC
`

func (q *Queries) GetAllPlaylist(ctx context.Context) ([]Playlist, error) {
	rows, err := q.db.Query(ctx, getAllPlaylist)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Playlist{}
	for rows.Next() {
		var i Playlist
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Thumbnail,
			&i.AccountID,
			&i.ArtistID,
			&i.CategoryID,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNewPlaylist = `-- name: GetNewPlaylist :many
SELECT p.id, p.name, p.thumbnail, p.account_id, p.artist_id, p.category_id, p.description, p.created_at, p.updated_at 
FROM playlist p 
WHERE p.account_id is null
ORDER BY p.created_at DESC
OFFSET 0
LIMIT 7
`

func (q *Queries) GetNewPlaylist(ctx context.Context) ([]Playlist, error) {
	rows, err := q.db.Query(ctx, getNewPlaylist)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Playlist{}
	for rows.Next() {
		var i Playlist
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Thumbnail,
			&i.AccountID,
			&i.ArtistID,
			&i.CategoryID,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlaylistByArtist = `-- name: GetPlaylistByArtist :many
SELECT p.id, p.name, p.thumbnail, p.account_id, p.artist_id, p.category_id, p.description, p.created_at, p.updated_at 
FROM playlist p WHERE p.artist_id = $1::int
`

func (q *Queries) GetPlaylistByArtist(ctx context.Context, artistID int32) ([]Playlist, error) {
	rows, err := q.db.Query(ctx, getPlaylistByArtist, artistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Playlist{}
	for rows.Next() {
		var i Playlist
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Thumbnail,
			&i.AccountID,
			&i.ArtistID,
			&i.CategoryID,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlaylistByCategories = `-- name: GetPlaylistByCategories :many
SELECT p.id, p.name, p.thumbnail, p.account_id, p.artist_id, p.category_id, p.description, p.created_at, p.updated_at 
FROM playlist p WHERE p.category_id = $1::int
`

func (q *Queries) GetPlaylistByCategories(ctx context.Context, categoryID int32) ([]Playlist, error) {
	rows, err := q.db.Query(ctx, getPlaylistByCategories, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Playlist{}
	for rows.Next() {
		var i Playlist
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Thumbnail,
			&i.AccountID,
			&i.ArtistID,
			&i.CategoryID,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlaylistById = `-- name: GetPlaylistById :one
SELECT p.id, p.name, p.thumbnail, p.account_id, p.artist_id, p.category_id, p.description, p.created_at, p.updated_at 
FROM playlist p WHERE p.id = $1::int
`

func (q *Queries) GetPlaylistById(ctx context.Context, id int32) (Playlist, error) {
	row := q.db.QueryRow(ctx, getPlaylistById, id)
	var i Playlist
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Thumbnail,
		&i.AccountID,
		&i.ArtistID,
		&i.CategoryID,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPlaylistByUserId = `-- name: GetPlaylistByUserId :many
SELECT p.id, p.name
FROM playlist p WHERE p.account_id = $1::int
ORDER BY p.created_at DESC
`

type GetPlaylistByUserIdRow struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) GetPlaylistByUserId(ctx context.Context, accountID int32) ([]GetPlaylistByUserIdRow, error) {
	rows, err := q.db.Query(ctx, getPlaylistByUserId, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPlaylistByUserIdRow{}
	for rows.Next() {
		var i GetPlaylistByUserIdRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlaylistofUser = `-- name: GetPlaylistofUser :many
SELECT id, name, thumbnail, account_id, artist_id, category_id, description, created_at, updated_at FROM playlist where account_id = $1 ORDER by created_at DESC
`

func (q *Queries) GetPlaylistofUser(ctx context.Context, accountID pgtype.Int4) ([]Playlist, error) {
	rows, err := q.db.Query(ctx, getPlaylistofUser, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Playlist{}
	for rows.Next() {
		var i Playlist
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Thumbnail,
			&i.AccountID,
			&i.ArtistID,
			&i.CategoryID,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSongInPlaylist = `-- name: GetSongInPlaylist :many
SELECT s.id, s.name, s.thumbnail, s.artist_id, s.path, s.lyrics, s.category_id, s.duration, s.release_date, s.created_at, s.updated_at , a.name as artist_name, a.avatar_url 
from playlist_song p 
INNER JOIN songs s ON p.song_id = s.id 
LEFT JOIN artist a on s.artist_id = a.id
WHERE p.playlist_id = $1
`

type GetSongInPlaylistRow struct {
	ID          int32            `json:"id"`
	Name        string           `json:"name"`
	Thumbnail   pgtype.Text      `json:"thumbnail"`
	ArtistID    int32            `json:"artist_id"`
	Path        pgtype.Text      `json:"path"`
	Lyrics      pgtype.Text      `json:"lyrics"`
	CategoryID  int32            `json:"category_id"`
	Duration    pgtype.Int4      `json:"duration"`
	ReleaseDate pgtype.Timestamp `json:"release_date"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
	ArtistName  pgtype.Text      `json:"artist_name"`
	AvatarUrl   pgtype.Text      `json:"avatar_url"`
}

func (q *Queries) GetSongInPlaylist(ctx context.Context, playlistID int32) ([]GetSongInPlaylistRow, error) {
	rows, err := q.db.Query(ctx, getSongInPlaylist, playlistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSongInPlaylistRow{}
	for rows.Next() {
		var i GetSongInPlaylistRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Thumbnail,
			&i.ArtistID,
			&i.Path,
			&i.Lyrics,
			&i.CategoryID,
			&i.Duration,
			&i.ReleaseDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ArtistName,
			&i.AvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSongNotInPlaylist = `-- name: GetSongNotInPlaylist :many
SELECT s.id, s.name, s.thumbnail, s.artist_id, s.path, s.lyrics, s.category_id, s.duration, s.release_date, s.created_at, s.updated_at , a.name as artist_name, a.avatar_url 
from songs s 
LEFT JOIN artist a on s.artist_id = a.id
WHERE s.id NOT IN (
    SELECT song_id from playlist_song p WHERE p.playlist_id = $1
) AND s.name ILIKE $2::varchar || '%'
OFFSET COALESCE($3::int, 0)
LIMIT COALESCE($4::int, 50)
`

type GetSongNotInPlaylistParams struct {
	PlaylistID int32  `json:"playlist_id"`
	Search     string `json:"search"`
	Start      int32  `json:"start"`
	Size       int32  `json:"size"`
}

type GetSongNotInPlaylistRow struct {
	ID          int32            `json:"id"`
	Name        string           `json:"name"`
	Thumbnail   pgtype.Text      `json:"thumbnail"`
	ArtistID    int32            `json:"artist_id"`
	Path        pgtype.Text      `json:"path"`
	Lyrics      pgtype.Text      `json:"lyrics"`
	CategoryID  int32            `json:"category_id"`
	Duration    pgtype.Int4      `json:"duration"`
	ReleaseDate pgtype.Timestamp `json:"release_date"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
	ArtistName  pgtype.Text      `json:"artist_name"`
	AvatarUrl   pgtype.Text      `json:"avatar_url"`
}

func (q *Queries) GetSongNotInPlaylist(ctx context.Context, arg GetSongNotInPlaylistParams) ([]GetSongNotInPlaylistRow, error) {
	rows, err := q.db.Query(ctx, getSongNotInPlaylist,
		arg.PlaylistID,
		arg.Search,
		arg.Start,
		arg.Size,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSongNotInPlaylistRow{}
	for rows.Next() {
		var i GetSongNotInPlaylistRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Thumbnail,
			&i.ArtistID,
			&i.Path,
			&i.Lyrics,
			&i.CategoryID,
			&i.Duration,
			&i.ReleaseDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ArtistName,
			&i.AvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeSongFromPlaylist = `-- name: RemoveSongFromPlaylist :exec
DELETE FROM playlist_song WHERE playlist_id = $1::int AND song_id = $2::int
`

type RemoveSongFromPlaylistParams struct {
	PlaylistID int32 `json:"playlist_id"`
	SongID     int32 `json:"song_id"`
}

func (q *Queries) RemoveSongFromPlaylist(ctx context.Context, arg RemoveSongFromPlaylistParams) error {
	_, err := q.db.Exec(ctx, removeSongFromPlaylist, arg.PlaylistID, arg.SongID)
	return err
}

const searchPlaylist = `-- name: SearchPlaylist :many
SELECT id, name, thumbnail, account_id, artist_id, category_id, description, created_at, updated_at FROM playlist where name ILIKE $1::varchar || '%' 
ORDER by created_at DESC
`

func (q *Queries) SearchPlaylist(ctx context.Context, search string) ([]Playlist, error) {
	rows, err := q.db.Query(ctx, searchPlaylist, search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Playlist{}
	for rows.Next() {
		var i Playlist
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Thumbnail,
			&i.AccountID,
			&i.ArtistID,
			&i.CategoryID,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePlaylist = `-- name: UpdatePlaylist :one
UPDATE playlist
SET name = $1, 
thumbnail = $2, 
artist_id = $3, 
description = $4,
category_id = $5,
updated_at = NOW()
WHERE id = $6
RETURNING id, name, thumbnail, account_id, artist_id, category_id, description, created_at, updated_at
`

type UpdatePlaylistParams struct {
	Name        string      `json:"name"`
	Thumbnail   pgtype.Text `json:"thumbnail"`
	ArtistID    pgtype.Int4 `json:"artist_id"`
	Description pgtype.Text `json:"description"`
	CategoryID  pgtype.Int4 `json:"category_id"`
	ID          int32       `json:"id"`
}

func (q *Queries) UpdatePlaylist(ctx context.Context, arg UpdatePlaylistParams) (Playlist, error) {
	row := q.db.QueryRow(ctx, updatePlaylist,
		arg.Name,
		arg.Thumbnail,
		arg.ArtistID,
		arg.Description,
		arg.CategoryID,
		arg.ID,
	)
	var i Playlist
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Thumbnail,
		&i.AccountID,
		&i.ArtistID,
		&i.CategoryID,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
