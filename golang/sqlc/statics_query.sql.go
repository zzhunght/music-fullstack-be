// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: statics_query.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const getSongViewStatistics = `-- name: GetSongViewStatistics :many
SELECT DATE_TRUNC('day', play_at)::date AS play_date, COUNT(*) AS view_count
FROM song_plays
WHERE play_at BETWEEN $1 AND $2
GROUP BY play_date
ORDER BY play_date
`

type GetSongViewStatisticsParams struct {
	StartDate pgtype.Timestamp `json:"start_date"`
	EndDate   pgtype.Timestamp `json:"end_date"`
}

type GetSongViewStatisticsRow struct {
	PlayDate  time.Time `json:"play_date"`
	ViewCount int64     `json:"view_count"`
}

func (q *Queries) GetSongViewStatistics(ctx context.Context, arg GetSongViewStatisticsParams) ([]GetSongViewStatisticsRow, error) {
	rows, err := q.db.Query(ctx, getSongViewStatistics, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSongViewStatisticsRow{}
	for rows.Next() {
		var i GetSongViewStatisticsRow
		if err := rows.Scan(&i.PlayDate, &i.ViewCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const statistics = `-- name: Statistics :one
SELECT
    (SELECT COUNT(*) FROM artist) AS total_artists,
    (SELECT COUNT(*) FROM accounts) AS total_users,
    (SELECT COUNT(*) FROM songs) AS total_songs,
    (SELECT COUNT(*) FROM albums) AS total_albums,
    (SELECT COUNT(*) FROM playlist) AS total_playlist
`

type StatisticsRow struct {
	TotalArtists  int64 `json:"total_artists"`
	TotalUsers    int64 `json:"total_users"`
	TotalSongs    int64 `json:"total_songs"`
	TotalAlbums   int64 `json:"total_albums"`
	TotalPlaylist int64 `json:"total_playlist"`
}

func (q *Queries) Statistics(ctx context.Context) (StatisticsRow, error) {
	row := q.db.QueryRow(ctx, statistics)
	var i StatisticsRow
	err := row.Scan(
		&i.TotalArtists,
		&i.TotalUsers,
		&i.TotalSongs,
		&i.TotalAlbums,
		&i.TotalPlaylist,
	)
	return i, err
}
